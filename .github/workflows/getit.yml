name: Channel Processor

on:
  schedule:
   # æ¯ä¸¤å°æ—¶æ‰§è¡Œä¸€æ¬¡
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘

jobs:
  process-channels:
    runs-on: ubuntu-latest
    name: ğŸ¬ Process Channel Lists
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4
      with:
        ref: master
        fetch-depth: 0

    - name: ğŸ Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.10"

    - name: ğŸ“¦ Install dependencies
      run: pip install requests

    - name: â¬‡ï¸ Download and process m3u file
      run: |
        echo "å¼€å§‹ä¸‹è½½å’Œå¤„ç†M3Uæ–‡ä»¶..."
        mkdir -p output
        python << 'EOF'
        import requests
        import re
        
        # ä¸‹è½½è¿œç¨‹m3uæ–‡ä»¶
        url = "https://raw.githubusercontent.com/develop202/migu_video/refs/heads/main/interface.txt"
        print(f"æ­£åœ¨ä» {url} ä¸‹è½½æ–‡ä»¶...")
        response = requests.get(url)
        m3u_content = response.text
        
        # è§£æm3uæ ¼å¼å¹¶è½¬æ¢ä¸ºtxtæ ‡å‡†æ ¼å¼
        lines = m3u_content.split('\n')
        output_lines = []
        
        # CCTVé¢‘é“åç§°æ ‡å‡†åŒ–æ˜ å°„
        channel_mapping = {
            "CCTV1ç»¼åˆ": "CCTV-1",
            "CCTV2è´¢ç»": "CCTV-2", 
            "CCTV3ç»¼è‰º": "CCTV-3",
            "CCTV4ä¸­æ–‡å›½é™…": "CCTV-4",
            "CCTV5ä½“è‚²": "CCTV-5",
            "CCTV5+ä½“è‚²èµ›äº‹": "CCTV-5+",
            "CCTV6ç”µå½±": "CCTV-6",
            "CCTV7å›½é˜²å†›äº‹": "CCTV-7",
            "CCTV8ç”µè§†å‰§": "CCTV-8",
            "CCTV9çºªå½•": "CCTV-9",
            "CCTV10ç§‘æ•™": "CCTV-10",
            "CCTV11æˆæ›²": "CCTV-11",
            "CCTV12ç¤¾ä¼šä¸æ³•": "CCTV-12",
            "CCTV13æ–°é—»": "CCTV-13",
            "CCTV14å°‘å„¿": "CCTV-14",
            "CCTV15éŸ³ä¹": "CCTV-15",
            "CCTV16å¥¥æ—åŒ¹å…‹": "CCTV-16",
            "CCTV17å†œä¸šå†œæ‘": "CCTV-17"
        }
        
        current_channel = None
        for line in lines:
            line = line.strip()
            if line.startswith('#EXTINF:'):
                # æå–é¢‘é“åç§°
                match = re.search(r',(.+)$', line)
                if match:
                    current_channel = match.group(1)
                    # åº”ç”¨é¢‘é“æ˜ å°„
                    for old_name, new_name in channel_mapping.items():
                        if old_name in current_channel:
                            current_channel = current_channel.replace(old_name, new_name)
            elif line.startswith('http'):
                if current_channel:
                    output_lines.append(f"{current_channel}, {line}")
                    current_channel = None
        
        # å†™å…¥å¤„ç†åçš„å†…å®¹
        with open('output/remote.txt', 'w', encoding='utf-8') as f:
            f.write('\n'.join(output_lines))
        
        print(f"âœ… æˆåŠŸå¤„ç† {len(output_lines)} ä¸ªé¢‘é“")
        print("å¤„ç†çš„é¢‘é“ç¤ºä¾‹:")
        for i, channel in enumerate(output_lines[:5]):
            print(f"  {i+1}. {channel.split(',')[0]}")
        EOF

    - name: ğŸ”„ Merge channels to user result
      run: |
        python << 'EOF'
        import os
        
        def read_channels(filename):
            """è¯»å–é¢‘é“æ–‡ä»¶ï¼Œè¿”å›é¢‘é“å­—å…¸"""
            if not os.path.exists(filename):
                print(f"âš ï¸ æ–‡ä»¶ {filename} ä¸å­˜åœ¨")
                return {}
            
            channels = {}
            with open(filename, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if line and ',' in line:
                        try:
                            name, url = line.split(',', 1)
                            channels[name.strip()] = url.strip()
                        except Exception as e:
                            print(f"âš ï¸ ç¬¬ {line_num} è¡Œè§£æå¤±è´¥: {e}")
            return channels
        
        def write_channels(filename, channels_dict):
            """å°†é¢‘é“å­—å…¸å†™å…¥æ–‡ä»¶"""
            with open(filename, 'w', encoding='utf-8') as f:
                for name, url in channels_dict.items():
                    f.write(f"{name}, {url}\n")
        
        print("å¼€å§‹åˆå¹¶é¢‘é“åˆ—è¡¨...")
        
        # è¯»å–remote.txtå’Œuserresult.txt
        remote_channels = read_channels('output/remote.txt')
        user_channels = read_channels('output/userresult.txt')
        
        print(f"ğŸ“Š ç»Ÿè®¡ä¿¡æ¯:")
        print(f"  - è¿œç¨‹é¢‘é“æ•°: {len(remote_channels)}")
        print(f"  - ç”¨æˆ·åŸæœ‰é¢‘é“æ•°: {len(user_channels)}")
        
        # ä¿®å¤ï¼šä¿ç•™æ‰€æœ‰åŸæœ‰é¢‘é“ï¼Œåªæ›´æ–°åŒ¹é…çš„é¢‘é“
        merged_channels = user_channels.copy()  # ä¿ç•™æ‰€æœ‰åŸæœ‰é¢‘é“
        
        update_count = 0
        add_count = 0
        
        for remote_name, remote_url in remote_channels.items():
            if remote_name in merged_channels:
                # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                existing_url = merged_channels[remote_name]
                if existing_url.startswith('http://gslbmgsplive.miguvideo.com'):
                    merged_channels[remote_name] = remote_url
                    update_count += 1
                    print(f"ğŸ”„ æ›´æ–°é¢‘é“: {remote_name}")
                else:
                    # ä¿æŒåŸæœ‰é¢‘é“ä¸å˜
                    print(f"ğŸ“ ä¿ç•™åŸæœ‰é¢‘é“: {remote_name}")
            else:
                # å¦‚æœç”¨æˆ·æ–‡ä»¶ä¸­æ²¡æœ‰è¯¥é¢‘é“ï¼Œå¯ä»¥é€‰æ‹©æ·»åŠ ï¼ˆè¿™é‡Œé€‰æ‹©ä¸æ·»åŠ ä»¥ä¿æŒåŸæœ‰ç»“æ„ï¼‰
                # å¦‚éœ€è¦æ·»åŠ ï¼Œå–æ¶ˆä¸‹é¢æ³¨é‡Šï¼š
                # merged_channels[remote_name] = remote_url
                # add_count += 1
                # print(f"â• æ·»åŠ æ–°é¢‘é“: {remote_name}")
                pass
        
        # å†™å…¥åˆå¹¶åçš„ç»“æœ
        write_channels('output/userresult.txt', merged_channels)
        
        print(f"ğŸ‰ åˆå¹¶å®Œæˆ!")
        print(f"ğŸ“ˆ æœ€ç»ˆç»Ÿè®¡:")
        print(f"  - æ€»é¢‘é“æ•°: {len(merged_channels)}")
        print(f"  - æ›´æ–°é¢‘é“æ•°: {update_count}")
        print(f"  - æ·»åŠ é¢‘é“æ•°: {add_count}")
        print(f"  - ä¿ç•™åŸæœ‰é¢‘é“æ•°: {len(merged_channels) - add_count}")
        EOF

    - name: ğŸ’¾ Commit and push changes
      run: |
        echo "æ£€æŸ¥æ–‡ä»¶å˜æ›´..."
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add output/
        
        # æ£€æŸ¥æ˜¯å¦æœ‰å˜æ›´éœ€è¦æäº¤
        if git diff --staged --quiet; then
          echo "ğŸ“­ æ²¡æœ‰æ£€æµ‹åˆ°æ–‡ä»¶å˜æ›´ï¼Œè·³è¿‡æäº¤"
        else
          echo "æ­£åœ¨æäº¤å˜æ›´..."
          git commit -m "Auto-update: Process channel lists $(date +'%Y-%m-%d %H:%M:%S')"
          git push origin master
          echo "âœ… å˜æ›´å·²æˆåŠŸæ¨é€åˆ°ä»“åº“"
        fi

  sync-to-gitee:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout GitHub Repo
        uses: actions/checkout@v4
        with:
          ref: master
       
      - name: Download files
        run: |
          curl -o IPV4.txt "https://raw.githubusercontent.com/${{ github.repository }}/master/output/userresult.txt"
          curl -o IPV6.txt "https://raw.githubusercontent.com/${{ github.repository }}/master/output/ipv6/result.txt"
          curl -o IPV4.m3u "https://raw.githubusercontent.com/${{ github.repository }}/master/output/userresult.m3u"

      - name: Clone Gitee Repo
        env:
          GITEE_USER: ${{ secrets.GITEE_USER }}
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          GITEE_REPO: ${{ secrets.GITEE_REPO }}
        run: |
          git clone "https://${GITEE_USER}:${GITEE_TOKEN}@gitee.com/${GITEE_USER}/${GITEE_REPO}.git" gitee-repo

      - name: Sync files
        run: |
          cd gitee-repo
          git config user.name "GitHub Actions"
          git config user.email "actions@users.noreply.github.com"
          git checkout master || git checkout -b master
          cp ../IPV4.txt ./
          cp ../IPV6.txt ./
          cp ../IPV4.m3u ./
          git add IPV4.txt IPV6.txt IPV4.m3u
          git commit -m "Sync from GitHub" || exit 0
          git push origin master
